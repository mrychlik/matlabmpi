head	1.14;
access;
symbols;
locks; strict;
comment	@// @;


1.14
date	2018.10.10.03.19.22;	author marek;	state Exp;
branches;
next	1.13;

1.13
date	2018.10.10.03.17.32;	author marek;	state Exp;
branches;
next	1.12;

1.12
date	2018.10.10.03.15.15;	author marek;	state Exp;
branches;
next	1.11;

1.11
date	2018.10.10.03.14.54;	author marek;	state Exp;
branches;
next	1.10;

1.10
date	2018.10.10.03.06.47;	author marek;	state Exp;
branches;
next	1.9;

1.9
date	2018.10.10.03.05.59;	author marek;	state Exp;
branches;
next	1.8;

1.8
date	2018.10.10.03.04.27;	author marek;	state Exp;
branches;
next	1.7;

1.7
date	2018.10.10.03.01.54;	author marek;	state Exp;
branches;
next	1.6;

1.6
date	2018.10.10.03.01.17;	author marek;	state Exp;
branches;
next	1.5;

1.5
date	2018.10.10.02.57.49;	author marek;	state Exp;
branches;
next	1.4;

1.4
date	2018.10.10.02.49.15;	author marek;	state Exp;
branches;
next	1.3;

1.3
date	2018.10.10.02.49.03;	author marek;	state Exp;
branches;
next	1.2;

1.2
date	2018.10.10.02.48.44;	author marek;	state Exp;
branches;
next	1.1;

1.1
date	2018.10.10.02.48.18;	author marek;	state Exp;
branches;
next	;


desc
@@


1.14
log
@*** empty log message ***
@
text
@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% M-file : matching_solver.m
%% Author: Marek Rychlik (10-9-2018)
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

classdef matching_solver < handle

    properties

        I;                              % Incidence matrix
        W;                              % Edge weights

        beta;                           % Inverse temp
        initial_beta;                   % Beta to start withh
        delta_beta;                     % Annealing - inverse temp increment
        gamma;                          % lower bound on optimal cost

        e;                              % Number of edges
        v;                              % Number of vertices

        R;
        num_runs;
        tau;
        visualize;                      % Turn visualization on/off
        num_epochs;                     % Number of epochs (= intervals)
        E_threshold;                    % Minimum change of energy

        gradient_delta = 1e-5;          % Delta for numerical gradient
        gradient_err_threshold = 1e-3;  % Gradient validation constant
        done = false;                   % Stop if this is set
    end

    properties(Constant)
        initial_best = struct('E', Inf, 'x', [], 'count', -1);
    end;

    properties(SetObservable, AbortSet)
        best = tsp_solver.initial_best;
    end


    methods
        function obj = matching_solver(I, W, varargin)
            p = inputParser;

            validIncidenceMatrix = @@(x) isnumeric(x);
            addRequired(p,'I',validIncidenceMatrix);

            validWeightMatrix = @@(x) isnumeric(x);
            addRequired(p,'W',validWeightMatrix);

            defaultBeta = 1;                    % Inverse temp.
            validBeta = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'beta', defaultBeta, validBeta);

            defaultDeltaBeta = .1;
            validDeltaBeta = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'betaIncrement', defaultDeltaBeta, validDeltaBeta);

            defaultTau = 1;
            validTau = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'tau', defaultTau, validTau);

            defaultNumRuns = 10;
            validNumRuns = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'numRuns', defaultNumRuns, validNumRuns);

            defaultNumEpochs = 1000;
            validNumEpochs = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'numEpochs', defaultNumEpochs, validNumEpochs);

            defaultEnergyTreshold = 1e-3;
            validEnergyThreshold = @@(x) isnumeric(x) && isscalar(x) && (x > 0);
            addParameter(p, 'energyThreshold', defaultEnergyTreshold, ...
                         validEnergyThreshold);

            defaultVisualize = false;
            validVisualize = @@(x) islogical(x) && isscalar(x);
            addParameter(p, 'visualize', defaultVisualize, validVisualize);

            parse(p, I, W, varargin{:});

            obj.I = p.Results.I;
            obj.W = p.Results.W;            

            obj.initial_beta = p.Results.beta;
            obj.delta_beta = p.Results.betaIncrement;
            obj.tau = p.Results.tau;
            obj.num_runs = p.Results.numRuns;
            obj.visualize = p.Results.visualize;
            obj.num_epochs = p.Results.numEpochs;
            obj.E_threshold = p.Results.energyThreshold;

            [obj.v, obj.e] = size(obj.I);
            obj.R = obj.v + obj.e;
            obj.gamma = 10;
        end

        function obj = sim(obj)
            obj.best  = tsp_solver.initial_best;
            for run = 1:obj.num_runs
                disp(sprintf('Run: %d', run));
                obj.beta = obj.initial_beta;
                [t, x, E] = seek_equilibrium(obj);
                E_final = E(end);

                % Round the final solution to the nearest vertex
                x_optimal = round(squeeze(x(end,:,:)));
                E_optimal = energy(obj, x_optimal);
                if obj.visualize
                    disp('Nearest vertex');
                    display(x_optimal);    
                    disp(sprintf('Energy at nearest vertex: %6.3f', E_optimal));
                end
                if E_optimal < obj.best.E
                    obj.best = struct('E', E_optimal, ...
                                      'x', x_optimal, ...
                                      'count', 1);
                elseif E_optimal == obj.best.E
                    obj.best.count = obj.best.count + 1;
                end

                if obj.done
                    disp('Done!!!');
                    break;
                end

                disp(sprintf('Best cost: %g, current: %g', obj.best.E, E_optimal));
            end
            disp('---------------- RESULTS ----------------');
            disp(sprintf('Best cost: %g', obj.best.E));
            disp(sprintf('Best configuration (seen %d/%d  times)', ...
                         obj.best.count, obj.num_runs));
            disp(obj.best.x);
        end

        function [tn, xn, En] = seek_equilibrium(obj)
        %Seek equilibrium state of the Hopfield-Tank model
        % [X, E] = SEEK_EQUILIBRIUM(P) accepts parameters P of the
        % Hopfield-Tank model and returns optimual equilibrium configuration
        % X. The second value is the energy of the state X.


            x0 = rand([obj.e, 1]);
            t0 = 0;

            tn = [];
            xn = [];    
            En = [];

            for epoch = 1:obj.num_epochs
                [t, x] = ode23(@@(x,t)vector_field(obj,x,t), [t0, t0+1], x0);

                x0 = x(end,:);
                t0 = t(end);

                xx = squeeze( x(end,:) );

                E = zeros(size(x,1),1);
                for j=1:size(x,1)
                    E(j) = energy(obj, squeeze(x(j,:)) );
                end

                % Gather results
                xn = [xn;x];
                tn=[tn;t];
                En = [En;E];

                % Visualization
                if mod(epoch, 2) == 0 && obj.visualize
                    subplot(2,2,[1,2]),plot(tn,En),
                    title(sprintf('Epoch: %3d, learning: %6.3g, beta: %6.3g', ...
                                  epoch, E(end), obj.beta)),
                    subplot(2,2,3),imagesc(xx),
                    title('Matrix'),
                    subplot(2,2,4),plot(tn,yn),
                    title('Entries vs. time'),
                    drawnow;
                end

                if range(E) < obj.E_threshold
                    if obj.visualize
                        disp(sprintf(['Stopping in epoch %3d on threshold ' ...
                                      'met.'], epoch));
                    end
                    break;
                end
                obj.beta = obj.beta + obj.delta_beta;
            end
        end

        function E = energy(obj, x)
        %Computes Hopfield-Tank energy
        % E = ENERGY(X) takes an N-by-N matrix X of values in (0,1)
        % and returns energy E according to the Hopfield-Tank Model
            E = obj.R .* sum(x .* (1 - x));
        end


        function g = energy_gradient(obj, x)
        %Computes the gradient of the Hopfield-Tank energy
        % G = ENERGY_GRADIENT(X) takes an N-by-N matrix X of values in (0,1)
        % and returns the matrix G of the same shape as X, which is
        % the gradient of the Hopfield-Tank energy.
            g = obj.R .* (ones([obj.e, 1]) - 2 .* x);
        end    

        function g = energy_gradient_est(obj, x)
        %Computes the gradient of the Hopfield-Tank energy
        % G = ENERGY_GRADIENT(X) takes an N-by-N matrix X of values in (0,1)
        % and returns the matrix G of the same shape as X, which is
        % the gradient of the Hopfield-Tank energy.
            g = zeros([obj.e,1]);
            for r = 1:obj.e
                x1 = x; x2 = x;
                x1(r) = x1(r) + obj.gradient_delta;
                x2(r) = x2(r) - obj.gradient_delta;
                g(r) = ( energy(obj, x1) - energy(obj, x2) ) ./...
                         (2 .* obj.gradient_delta);
            end
        end    

        function dxdt = vector_field(obj, t, x)
        %Computes the vector field
            g = energy_gradient(obj, x);% Find gradient
            b = tsp_solver.sigmoid( -obj.beta .* g );% find activity
            dxdt = - (x - b) ./ obj.tau;% Define vector field
        end

        function r = validate(obj)
            x   = rand([obj.e, 1]);
            g1  = energy_gradient_est(obj, x);
            g   = energy_gradient(obj, x);
            err = norm(g1(:) - g(:))
            if err < obj.gradient_err_threshold
                r = true;
            else
                r = false;
            end
        end
    end;                                

    methods(Static)
        function y = sigmoid(x)
            y = 1 ./ (1 + exp(-x));
        end
    end

end@


1.13
log
@*** empty log message ***
@
text
@d233 3
a235 3
            x = rand([obj.e, 1]);
            g1 = energy_gradient_est(obj, x);
            g = energy_gradient(obj, x);
@


1.12
log
@*** empty log message ***
@
text
@d154 1
a154 1
                [t, x] = ode23(@@(y,t)vector_field(obj,x,t), [t0, t0+1], x0);
@


1.11
log
@*** empty log message ***
@
text
@d198 1
a198 1
            E = obj.R .* sum(x .* (1 - x), 'all');
@


1.10
log
@*** empty log message ***
@
text
@d146 1
a146 1
            x0 = rand([obj.e]);
d207 1
a207 1
            g =obj.R .* (ones([obj.n, obj.n]) - 2 .* x);
d215 7
a221 10
            g = zeros([obj.n,obj.n]);
            for r = 1:obj.n
                for c = 1:obj.n
                    x1 = x; x2 = x;
                    x1(r,c) = x1(r,c) + obj.gradient_delta;
                    x2(r,c) = x2(r,c) - obj.gradient_delta;
                    g(r,c) = ( energy(obj, x1) - energy(obj, x2) ) ./...
                             (2 .* obj.gradient_delta);
                                                                      
                end
d233 1
a233 1
            x = rand([obj.n, obj.n]);
@


1.9
log
@*** empty log message ***
@
text
@d228 1
a228 1
        function dydt = vector_field(obj, t, y)
a229 1
            x = reshape(y, [obj.n, obj.n]);% Translate to 2D array
a232 1
            dydt = dxdt(:);             % Translate to 1D array
@


1.8
log
@*** empty log message ***
@
text
@d198 1
a198 4
            E = sum(obj.d .* (x * circshift(x, -1, 2)'), 'all') ...
                + obj.gamma .* sum( (sum(x, 1) - 1) .^ 2) ...
                + obj.gamma .* sum( (sum(x, 2) - 1) .^ 2 ) ...
                + obj.R .* sum(x .* (1 - x), 'all');
d207 1
a207 6
            g = obj.d  * circshift(x,  -1, 2)  + ...
                obj.d' * circshift(x, 1, 2) ...
                + 2 .* obj.gamma .* ( (sum(x,2) - 1) * ones(1, obj.n) ) ...
                + 2 .* obj.gamma .* ( ones(obj.n, 1) * (sum(x,1) - 1) ) ...
                + obj.R .* (ones([obj.n, obj.n]) - 2 .* x);
            g(1,1) = g(1,1) + 2 .* obj.gamma .* (x(1,1)-1);
@


1.7
log
@*** empty log message ***
@
text
@d154 3
a156 3
                [t, y] = ode23(@@(y,t)vector_field(obj,y,t), [t0, t0+1], y0);
                %[t, y] = ode45(@@(y,t)vector_field(obj,y,t), [t0, t0+1], y0);                
                y0 = y(end,:);
d159 1
a159 2
                x = reshape(y, [size(y,1), obj.n, obj.n]);
                xx = squeeze( x(end,:,:) );
d163 1
a163 1
                    E(j) = energy(obj, squeeze(x(j,:,:)) );
a168 1
                yn=[yn;y];        
d201 1
a201 3
                + obj.R .* sum(x .* (1 - x), 'all') ...
                + obj.gamma .* (x(1,1)-1)^2;
            ;
@


1.6
log
@*** empty log message ***
@
text
@d146 1
a146 1
            x0 = rand([obj.n, obj.n]);
a147 1
            y0 = x0(:);
a149 1
            yn = [];
@


1.5
log
@*** empty log message ***
@
text
@d36 1
a36 1
        initial_best = struct('E',Inf, 'x', [], 'count', -1);
d96 3
a98 3
            obj.n = size(obj.d, 1);
            obj.R = obj.n;
            obj.gamma = min(sum(max(obj.d,[],1)), sum(max(obj.d,[],2)));
@


1.4
log
@*** empty log message ***
@
text
@d45 1
a45 1
        function obj = tsp_solver(I, W, varargin)
@


1.3
log
@*** empty log message ***
@
text
@d83 1
a83 1
            parse(p, W, varargin{:});
@


1.2
log
@*** empty log message ***
@
text
@d83 1
a83 1
            parse(p, d, varargin{:});
@


1.1
log
@Initial revision
@
text
@d87 1
@
